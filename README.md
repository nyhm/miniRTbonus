# miniRT

直すとこと
mandatryは１種類につき1回しか宣言できない
空白が続いてもいいようにする
ミスがある時に弾けるようにする


手順

1.rtファイルの読み込み（パース）
2シーン情報の格納（構造体）
3各ピクセルに対してレイを生成
4レイとオブジェクトの交差判定
5最も近い交差点の色を計算（ライティング）
6ピクセルに色を設定（画像バッファに書き込み）
7最後にウィンドウに画像を表示

1
A 0.2 255,255,255       // Ambient light
C -50,0,20 0,0,1 70     // Camera
L -40,0,30 0.7 255,255,255 // Light
sp 0,0,20 20 255,0,0    // Sphere
pl 0,0,0 0,1,0 0,255,0  // Plane
cy 50.0,0.0,20.6 0,0,1 14.2 21.42 10,0,255 // Cylinder

パーサーで読み込んで、分割　先頭の文字に応じて関数を適応
splitで分割をしてatof?で数値化

2
情報を構造体に格納

3
cameraの視点から各ピクセルの位置にレイを飛ばす
レイは始点と方向のセット
ベクトルを求める

4
レイとオブジェクトの交差をはんていする
物体と直線の交点を求め、交点が１つなら端、２つならぶつかっている、０ならぶつかっていない
この時に物体の前後も判定する
物体との交錯点を保持して、一番カメラとの距離が近い点を表示する

5
ライティング
影を計算
光の当たるところをカメラ同様に計算をして、当たったところが色が見える
その光線の途中に他の物体があったら陰になるから黒になる
平面がある場合は平面にも影ができる
最終的に見える色を確定する
(ここで物体の前後を判定している？？)

6
画像バッファに書き込み

7
最後にウィンドウに画像を表示
loopさせ、keyに応じて終了やcameraの変化




mlx_loopについて
    mlxで必要となる構造体は mlx_init();で作ることができる
    よって

    t_data data;-[miniRT.h](./miniRT.h)
    の構造体の中にvoid *mlxを持たせ

    data->mlx = mlx_init();-[render.c](./render.c)
    をしてから

    mlx_loop(data->mlx);-[main.c](./main.c)
    と渡すことで実行できる.

mlx_key_hook(data.win, keyhook, &data);
    keyhookを関数として呼び出す
    data



やりたいこと
    .rtファイルから
    A 0.2 255,255,255
    C -50.0,0,20 0,0,1 70
    L -40.0,50.0,0.0 0.6 10,0,255
    sp 0.0,0.0,20.6 12.6 10,0,255
    pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,225
    cy 50.0,0.0,20.6 0.0,0.0,1.0 14.2 21.42 10,0,255
    これを読み込んで反映させる
    各要素に関する最初の情報は型識別子（一文字または二文字）であり、それに続いて各オブジェクトに特有の情報が厳密な順序で記述されます。以下はその例です：
    ◦ 環境光（Ambient lighting）:
    A 0.2 255,255,255
        識別子：A
        環境光の比率（範囲：[0.0～1.0]）：0.2
        R, G, Bの色成分（範囲：[0～255]）：255, 255, 255
    ◦ カメラ（Camera）:
    C -50.0,0,20 0,0,1 70
        識別子：C
        視点のx, y, z座標：-50.0, 0, 20
        正規化された3D方向ベクトル（各x, y, z成分が[-1～1]の範囲）：0.0, 0.0, 1.0
        視野角（FOV）：水平方向の視野角（度数、範囲：[0～180]）：70
    ◦ 光源（Light）:
    L -40.0,50.0,0.0 0.6 10,0,255
        識別子：L
        光源位置のx, y, z座標：-40.0, 50.0, 0.0
        光の輝度比率（範囲：[0.0～1.0]）：0.6
        （必須部分では未使用）R, G, Bの色成分（範囲：[0～255]）：10, 0, 255
    ◦ 球体（Sphere）:
    sp 0.0,0.0,20.6 12.6 10,0,255
        識別子：sp
        球体中心のx, y, z座標：0.0, 0.0, 20.6
        球体の直径：12.6
        R, G, Bの色成分（範囲：[0～255]）：10, 0, 255
    ◦ 平面（Plane）:
    pl 0.0,0.0,-10.0 0.0,1.0,0.0 0,0,225
        識別子：pl
        平面上の任意の点のx, y, z座標：0.0, 0.0, -10.0
        正規化された法線ベクトル（各x, y, z成分が[-1～1]の範囲）：0.0, 1.0, 0.0
        R, G, Bの色成分（範囲：[0～255]）：0, 0, 225
    ◦ 円柱（Cylinder）:
    cy 50.0,0.0,20.6 0.0,0.0,1.0 14.2 21.42 10,0,255
        識別子：cy
        円柱の中心のx, y, z座標：50.0, 0.0, 20.6
        正規化された円柱の軸ベクトル（各x, y, z成分が[-1～1]の範囲）：0.0, 0.0, 1.0
        円柱の直径：14.2
        円柱の高さ：21.42
        R, G, Bの色成分（範囲：[0～255]）：10, 0, 255




Your program must be able to apply translation and rotation transformations to objects, lights, and cameras (except for spheres and lights that cannot be rotated).
オブジェクト、ライト、カメラに対して、移動（平行移動）と回転変換を適用できなければなりません（回転できない球とライトは除きます）。
Light management: spot brightness, hard shadows, ambient lighting (objects are never completely in the dark). You must implement ambient and diffuse lighting.
光の管理：スポットの明るさ、硬い影、環境光（オブジェクトが完全に暗くなることはありません）。環境光と拡散光を実装する必要があります。

Each type of element can be separated by one or more line breaks.
要素の種類ごとに1行以上の空行で区切ることができます。
Each type of information from an element can be separated by one or more spaces.
要素の各情報は1つ以上のスペースで区切ることができます。
Elements defined by a capital letter can only be declared once in the scene.
大文字で定義される要素はシーン内で1回だけ宣言できます。
